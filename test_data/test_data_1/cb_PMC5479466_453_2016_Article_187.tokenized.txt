algorithmica algorithmica algorithmica 0178 - 4617 1432 - 0541 springer us new york 28690348 5479466 187 10.1007 / s00453 - 016 - 0187 - y article populations can be essential in tracking dynamic optima dang duc - cuong duc - cuong.dang @ nottingham.ac.uk 1 jansen thomas t.jansen @ aber.ac.uk 2 lehre per kristian perkristian.lehre @ nottingham.ac.uk 1 1 0000 0004 1936 8868grid.4563.4asap research group , school of computer science , university of nottingham , jubilee campus , wollaton road , nottingham , ng8 1bb uk 2 0000000121682483grid.8186.7department of computer science , aberystwyth university , penglais campus , llandinam building , aberystwyth , sy23 3db uk 26 8 2016 26 8 2016 2017 78 2 660 680 12 10 2015 9 7 2016 ( c ) the author ( s ) 2016 open accessthis article is distributed under the terms of the creative commons attribution 4.0 international license ( http :// creativecommons.org / licenses / by / 4.0 /) , which permits unrestricted use , distribution , and reproduction in any medium , provided you give appropriate credit to the original author ( s ) and the source , provide a link to the creative commons license , and indicate if changes were made .
real - world optimisation problems are often dynamic .
previously good solutions must be updated or replaced due to changes in objectives and constraints .
it is often claimed that evolutionary algorithms are particularly suitable for dynamic optimisation because a large population can contain different solutions that may be useful in the future .
however , rigorous theoretical demonstrations for how populations in dynamic optimisation can be essential are sparse and restricted to special cases .
this paper provides theoretical explanations of how populations can be essential in evolutionary dynamic optimisation in a general and natural setting .
we describe a natural class of dynamic optimisation problems where a sufficiently large population is necessary to keep track of moving optima reliably .
we establish a relationship between the population - size and the probability that the algorithm loses track of the optimum .
keywords runtime analysis population - based algorithm dynamic optimisation http :// dx.doi.org / 10.13039 / 501100004963seventh framework programme618091 lehre per kristian issue - copyright - statement ( c ) springer science + business media new york 2017 introduction in a classical optimisation setting , so - called static optimisation , the focus is usually directed to finding an optimal or a high quality solution as fast as possible .
in real - world optimisation , problem specific data may change over time , thus previously good solutions can lose their quality and must be updated or replaced .
automatic optimal control is a typical illustration of these situations , e. g. parameters of a machine can be set optimally under ideal conditions of a factory but they need to be adapted to changes in the real environment upon deployment .
dynamic optimisation is an area of research that is concerned with such optimisation problems that change over time .
a specific characteristic is that it does not only focus on locating an optimal solution but also on tracking a moving optimum ( see [ 7 ] for a definition ) .
it is often suggested that evolutionary algorithms ( eas ) , especially the ones with populations , are suitable for dynamic optimisation because a large population can contain different solutions which could be useful in the future [ 22 ] .
however , theoretical demonstrations for how populations in dynamic optimisation can be essential are sparse and restricted to special cases .
the ability of a very simple ea without a population , the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea , to track a target bitstring in a onemax - like function is analysed in [ 4 , 20 ] .
the analysis has recently been extended from bitstrings to larger alphabets [ 11 ] .
the influence of magnitude and frequency of changes on the efficiency of the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea in optimising a specifically designed function was investigated in [ 19 ] , showing that some dynamic optimisation problems become easier with higher frequency of change .
the analysis of the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 +\ lambda )$$\ end { document }( 1 + lambda ) ea that uses a larger offspring population but still not a real population on a simple lattice problem is presented in [ 9 ] .
the efficiencies of specific diversity mechanisms when using an actual population were compared in [ 18 ] .
this was done for a specific example function ( introduced by [ 19 ]) and considering low frequency of changes .
it was shown in [ 12 ] that a min - max ant system ( mmas ) can beat the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea in a deterministic dynamic environment .
the comparison was later extended to general alphabets and to the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mu + 1 )$$\ end { document }( mu + 1 ) ea that preserves genotype diversity [ 15 ]. with that particular setting of the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mu + 1 )$$\ end { document }( mu + 1 ) ea , the size of the alphabets defines a threshold on the parent population size \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mu $$\ end { document } mu so that the algorithm is able to track and reach the optimal solution in polynomial time .
the result was also extended to the single - destination shortest path problem [ 14 ] .
comparisons were also made between eas and artificial immune system ( ais ) on a onemax - like problem with the dynamic being periodic [ 10 ] .
considering the existing analyses we can in summary note two shortcomings that leave the impression that important fundamental questions about dynamic optimisation are still not answered satisfactorily .
one shortcoming is the concentration on simple evolutionary algorithms and other search heuristics that do not make use of an actual population .
clearly , the advantages of a population - based approach cannot be explored and explained this way .
the other is that many studies consider very complex dynamic environments that make it hard to see the principal and fundamental issues .
therefore , the fundamental question why even a simple population without complicated diversity mechanisms can be helpful in dynamic environments requires more attention .
motivated by the above facts , we will use a simple argument considering a very general class of dynamic functions to show that a population is essential to keep track of the optimal region .
we define our function class on the most often used search space , bit strings of a fixed length .
however , it is not difficult to extend the function class to be defined for any finite search space \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathcal { x }$$\ end { document } x and any unary mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } :\ mathcal { x } \ rightarrow \ mathcal { x }$$\ end { document } pmut : x - - > x. the class is called \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( cn ,\ rho )$$\ end { document }( cn,rho ) - stable on \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathcal { x }$$\ end { document } x with respect to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut , where n is the required number of bits to specify a search point of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathcal { x }$$\ end { document } x and c and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho $$\ end { document } rho are positive constants independent of n. the function class is only restricted by the probability of recovering the optimal region via the mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }$$\ end { document } pmut ( see definition 4 ) .
the definition of the function class does not refer explicitly to other function characteristics , such as the topology or the fitness values of the set of optimal solutions , or the distribution of fitness values of the set of non - optimal solutions .
we will use the moving hamming ball function from [ 2 ] as an illustrative example over the search space \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\{ 0,1 \}^{ n }$$\ end { document }{ 0,1 } n and with respect to the bitwise mutation operator .
we also use this specific function to argue that an approach based on a single individual , such as the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea , is inefficient in tracking the optimal region in spite of being equipped with the same mutation operator .
on the other hand , we show that a population - based algorithm with a sufficiently large population can efficiently track the moving optimal region of any dynamic function of the class defined for any given finite search space .
the remainder of the paper is organised as follows .
the next section first gives a formal description of dynamic optimisation and efficient tracking , then the class of dynamic functions that we consider is described with an example function .
next , we consider the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea and rls on the function class and provide an analysis to serve as an example how search heuristics based on single solutions are not able to track the optimal solutions over time .
the efficiency of population - based algorithms is then explained by proving a positive result about their performance .
here , we use the setting of non - elitist populations and show that , with a sufficient selective pressure , the ability of the population to track the moving optimal region is overwhelmingly high with respect to the population size .
on the other hand , as a consequence of a fair comparison to a single - individual approach , the population must not be too big in order to capture the frequency of changes .
finally , we summarise , conclude and point out directions for future research .
the paper uses the following notation and terminology .
for any positive integer n , define \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$[ n ]{:=}\{ 1,2 ,\ ldots , n \}$$\ end { document }[ n ]:={ 1,2 ,... , n } .
the natural logarithm is denoted by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ln (\ cdot )$$\ end { document } ln (.) , and the logarithm to the base 2 is denoted by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ log (\ cdot )$$\ end { document } log (.) .
the hamming distance is denoted by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { h }(\ cdot ,\ cdot )$$\ end { document } h (.,.) and the iverson bracket is denoted by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$[\ cdot ]$$\ end { document }[.] .
we use \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbbm { 1 }_{ a }$$\ end { document } 1a to denote the indicator function of a set a , i.e. \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbbm { 1 }_{ a }( x ) = 1 $$\ end { document } 1a ( x )= 1 if \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ in a $$\ end { document } xina , and 0 otherwise .
for a given bitstring \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ in \{ 0,1 \}^ n $$\ end { document } xin { 0,1 } n , the hamming ball around x with radius r is denoted by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { b }_ r ( x ):=\{ y \ in \{ 0,1 \}^ n \ mid \ mathrm { h }( x,y ) \ le r \}$$\ end { document } br ( x ):={ yin { 0,1 } n | h ( x,y )<= r } .
the bitstring containing n one - bits and no zero - bits is denoted \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ 1 ^ n $$\ end { document } 1n .
an event is said to occur with overwhelmingly high probability ( w. o. p. ) with respect to a parameter n , if the probability of the event is bounded from below by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ 1 - e ^{ - \ varomega ( n )}$$\ end { document } 1 - e - omega ( n ) .
a general class of dynamic functions before defining the class of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ kappa ,\ rho )$$\ end { document }( kappa,rho ) - stable dynamic functions which will be studied in this paper , we first formalise our notion of dynamic optimisation , and we define what we mean when saying that a dynamic search heuristic tracks a moving optimal region efficiently .
a formal description of dynamic optimisation we focus on optimisation of pseudo - boolean functions with discrete - time dynamics , as formalised below .
note that our formalisation can be generalised to any finite search space \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathcal { x }$$\ end { document } x , e.g. replacing \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\{ 0,1 \}^ n $$\ end { document }{ 0,1 } n with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathcal { x }$$\ end { document } x , and our results for population - based algorithms also hold for this generalisation .
definition 1 a dynamic function f is a random sequence of functions \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( f _ t )_{ t \ in \ mathbb { n }},$$\ end { document }( ft ) tinn , where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f _ t :\{ 0,1 \}^ n \ rightarrow \ mathbb { r }$$\ end { document } ft :{ 0,1 } n - - > r for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t \ in \ mathbb { n }$$\ end { document } tinn .
the optimal regions associated with f is the sequence \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mathrm { opt }_{ t })_{ t \ in \ mathbb { n }}$$\ end { document }( optt ) tinn , where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{ t }=\ arg \ max _ x f _ t ( x )$$\ end { document } optt = argmaxxft ( x ) .
the perhaps simplest , non - trivial example of a dynamic function is a periodic function which deterministically alternates between two functions , say \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ g _ 1 $$\ end { document } g1 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ g _ 2 $$\ end { document } g2 , such that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f _{ 2i - 1 }= g _ 1 $$\ end { document } f2i - 1 = g1 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f _{ 2i }= g _ 2 $$\ end { document } f2i = g2 for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i \ in \ mathbb { n }$$\ end { document } iinn .
we will consider more complex dynamic functions , where the sequence of functions is random and non - periodic .
although the sequence of functions in a dynamic function is random , each individual function is deterministic , i.e. , we do not consider dynamic optimisation with noisy functions .
in this paper , we do not make any assumption about the changes of the function and the speed of the algorithm .
it has been pointed out that it is important to consider the relationship between the speed of the execution platform where the algorithm runs and the speed of change of the function because this has significant influence on the performance [ 10 ] .
almost all studies assume that the function cannot change within one generation of the algorithm .
the only exception we are aware of is a paper by branke and wang [ 1 ] who analyse a ( 1 , 2 ) ea. we follow this idea but consider a much broader class of algorithms .
when applying a search heuristic to a dynamic function , we therefore have to consider two time lines : the first is associated with the evolution of the dynamic function , and the second is associated with the search points generated by the heuristic .
following the convention from black - box complexity [ 6 ] , we assume that the function evaluations are the most expensive operations , for sake of the analysis becoming the basic time steps of an algorithm .
the time consumed by all other operations , such as sampling an individual or applying a mutation operator , is assumed to be negligible .
we connect the two time - lines by assuming that every time the heuristic queries a search point , the time - line of the dynamic function increases by one .
we allow dynamic search heuristics some flexibility in that search points can be queried not only with respect to the most recent function \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f _ t $$\ end { document } ft , but also with respect to past functions .
for example , the individuals in a population can be evaluated with respect to one particular time .
we also assume that the decisions made by the search heuristic does not influence the dynamic of the function .
the dynamic optimisation - scenario we have described is summarised in the following definition .
definition 2 a dynamic search heuristic is an algorithm which given a search history \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ left ( ( x _ j,i _ j,f _{ i _ j }( x _ j )\ right ) _{ j \ in [ t - 1 ]}$$\ end { document }( xj,ij,fij ( xj ) jin [ t - 1 ] of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t - 1 $$\ end { document } t - 1 elements in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\{ 0,1 \}^ n \ times \ mathbb { n }\ times \ mathbb { r }$$\ end { document }{ 0,1 } nxnxr , selects a search point \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t \ in \{ 0,1 \}^ n $$\ end { document } xtin { 0,1 } n and an evaluation time \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i _ t \ in [ t ]$$\ end { document } itin [ t ] , and evaluates \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f _{ i _ t }( x _ t )$$\ end { document } fit ( xt ) .
an element \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t , i _ t , f _{ i _ t }( x _ t ))$$\ end { document }( xt,it,fit ( xt )) in a search history describes the search point \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t $$\ end { document } xt queried by the algorithm in step t , the time point \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i _ t \ le t $$\ end { document } it <= t with which the search point is evaluated , and the corresponding function value \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f _{ i _ t }( x _ t )$$\ end { document } fit ( xt ) .
we can now formalise the notion of efficient tracking of optima .
definition 3 a search heuristic is said to efficiently track the optima of a dynamic function f if there exist \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _ 0 ,\ ell \ in {{\ mathrm { poly }}}( n )$$\ end { document } t0,linpoly ( n ) and constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c,c ^{\ prime }> 0 $$\ end { document } c,c '> 0 such that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ min _{ t _ 0 < t < e ^{ cn }}\ pr \ left ( \ sum _{ i = t }^{ t +\ ell }\ mathbbm { 1 }_{\{ x _ i \ in \ mathrm { opt }_{ i }\}} \ ge c ^{\ prime }\ ell \ right ) \ ge 1 - e ^{ - \ varomega ( n )} , \ end { aligned }$$\ end { document } mint0 < t < ecnprsumi = tt + l1 { xiinopti }>= c'l >= 1 - e - omega ( n ) , where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ ge 0 }$$\ end { document }( xt ) t >= 0 is the sequence of search points queried by the heuristic , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mathrm { opt }_{ t })_{ t \ ge 0 }$$\ end { document }( optt ) t >= 0 is the sequence of optimal search points of function f. informally , definition 3 means that the algorithm queries optimal search points frequently .
more precisely , within every sub - interval of length \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell $$\ end { document } l within the exponentially long time interval from \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _ 0 $$\ end { document } t0 to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ e ^{ cn }$$\ end { document } ecn , a constant fraction of the queried search points are optimal .
note that the optimality of a search point is defined with respect to the query time , and regardless of the function with which the algorithm evaluates the search point .
the constraint \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell \ in {{\ mathrm { poly }}}( n )$$\ end { document } linpoly ( n ) on the length of sub - intervals guarantees that the time between generation of two optimal search points is bounded from above by a polynomial .
it is clear from the definition that an algorithm is inefficient if with a sufficiently high probability , e.g. at least constant , it loses track of the optimal region and does not recover it within a polynomial number of steps .
a class of stable dynamic functions the class of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ kappa ,\ rho )$$\ end { document }( kappa,rho ) - stable dynamic functions with respect to a variation operator is defined as follows .
definition 4 let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ phi :\{ 0,1 \}^ n \ rightarrow \{ 0,1 \}^ n $$\ end { document } phi :{ 0,1 } n - - >{ 0,1 } n be any unary variation operator , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ kappa \ in \ mathbb { n }$$\ end { document } kappainn , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho \ in ( 0,1 )$$\ end { document } rhoin ( 0,1 ) .
if there exist constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c,c ^{\ prime }> 0 $$\ end { document } c,c '> 0 such that with probability at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ 1 - e ^{ - c ^{\ prime }\ kappa }$$\ end { document } 1 - e - c'kappa , the optimal regions \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mathrm { opt }_{ t })_{ t \ in \ mathbb { n }}$$\ end { document }( optt ) tinn of a function f satisfy for all time points t and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t ^{\ prime }$$\ end { document } t ' with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ 0 < t < t ^{\ prime } \ le t +\ kappa < e ^{ c \ kappa }$$\ end { document } 0 < t < t '<= t + kappa < eckappa , and for all search points \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ in \ mathrm { opt }_{ t }$$\ end { document } xinoptt ,\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( \ phi ( x ) \ in \ mathrm { opt }_{ t ^{\ prime }}\ right ) \ ge \ rho \ end { aligned }$$\ end { document } prphi ( x ) inoptt '>= rhothen f is called \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ kappa ,\ rho )$$\ end { document }( kappa,rho ) - stable with respect to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ phi $$\ end { document } phi .
definition 4 covers a large class of dynamic optimisation functions for any given pair of parameters \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ kappa ,\ rho )$$\ end { document }( kappa,rho ) .
the optimal regions over time can take many shapes , including disconnected pieces over \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\{ 0,1 \}^ n $$\ end { document }{ 0,1 } n as long as the distances between them and the cardinality of the intersections allow the probabilistic condition to hold .
figure 1 illustrates the required condition .
given an operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ phi $$\ end { document } phi , we focus on the class of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( cn ,\ rho )$$\ end { document }( cn,rho ) - stable functions where c and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho $$\ end { document } rho are positive constants .
we will show that a population - based algorithm with a sufficiently large population and a sufficiently strong selection pressure can track the optimal region of any function in the class efficiently .
the next section gives an example function of the class for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ phi $$\ end { document } phi being bitwise mutation and explains how it fits within the framework of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( cn ,\ rho )$$\ end { document }( cn,rho ) - stable function .
we will then use the example function to argue that algorithms that base their search on a single individual , such as the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea , can be inefficient. fig. 1 illustration of a \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ kappa ,\ rho )$$\ end { document }( kappa,rho ) - stable dynamic function , in which any search point in the optimal region of time t can be mutated into the optimal region of time \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t +\ kappa $$\ end { document } t + kappa with probability at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho $$\ end { document } rho example of a stable pseudo - boolean function we consider the moving hamming ball function as described in [ 2 ] .
the static version of the function has the following form .
definition 5 the hamming ball function around a target bitstring \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x ^{*}$$\ end { document } x * and a radius r is defined as ,\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathrm { hb }^{ r,x ^{*}}( x )&={\ left \{ \ begin { array }{ ll } 1 &{}\ text { if }\ mathrm { h }( x , x ^{*}) \ le r , \\ 0 &{}\ text { otherwise } .
\ end { array }\ right .
} \ end { aligned }$$\ end { document } hbr,x *( x )= 1ifh ( x,x *)<= r,0otherwise .
it suffices to change \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x ^{*}$$\ end { document } x * in sequential steps to create a dynamic version from the static one .
we use the following dynamic setting for the function : the points in time when the target \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x ^{*}$$\ end { document } x * is changed are determined by a sequence of random variables drawn from a poisson distribution .
definition 6 let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ i )_{ i \ in \ mathbb { n }}$$\ end { document }( xi ) iinn be a sequence of random variables independently sampled from a poisson distribution with parameter \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ theta $$\ end { document } theta , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ i \ sim {{\ mathrm { pois }}}(\ theta )$$\ end { document } xi ~ pois ( theta ) , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell $$\ end { document } l be some integer in [ n ] , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ left ( x ^{*}_ i \ right ) _{ i \ in \ mathbb { n }}$$\ end { document } xi * iinn be a sequence of bitstrings generated by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } x ^{*}_ i &= {\ left \{ \ begin { array }{ ll } 1 ^ n &{} \ text { if } i = 0 , \\ \ sim {{\ mathrm { unif }}}\ left ( \ left \{ y \ left | \ mathrm { h }\ left ( x ^{*}_{ i - 1 } , y \ right ) = \ ell \ right \} \ right ) \ right .
&{} \ text { otherwise .
} \ end { array }\ right .
} \ end { aligned }$$\ end { document } xi *= 1nifi = 0 ,~ unifyhxi - 1 * , y = lotherwise.the moving hamming ball (\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }$$\ end { document } mhb ) function with parameters r , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell $$\ end { document } l , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ theta $$\ end { document } theta is defined as \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned }&\ mathrm { mhb }^{ r ,\ ell ,\ theta }_ t ( x )= \ mathrm { hb }^{ r,x ^{*}( t )}( x ) \\&\ text { where } x ^{*}( t )= x ^{*}_{\ max \{ j \ mid \ sum _{ i = 1 }^{ j } x _ i \ le t \}} .
\ end { aligned }$$\ end { document } mhbtr,l,theta ( x )= hbr,x *( t )( x ) wherex *( t )= xmax { j | sumi = 1jxi <= t }* .
the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }$$\ end { document } mhb function fits within the stability framework of definition 4 with respect to the bitwise mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }^\ mathrm { ea } $$\ end { document } pmutea .
this variation operator , which has a parameter \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ chi \ in [ 0,n ]$$\ end { document } chiin [ 0,n ] , flips each position in the bitstring independently with probability \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ chi / n $$\ end { document } chi / n. hence , the probability of mutating a bitstring \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ in \{ 0,1 \}^ n $$\ end { document } xin { 0,1 } n into a bitstring \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y \ in \{ 0,1 \}^ n $$\ end { document } yin { 0,1 } n is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( y = p _\ mathrm { mut }^\ mathrm { ea } ( x )\ right ) = \ left ( \ frac {\ chi }{ n }\ right ) ^{ h ( x,y )}\ left ( 1 - \ frac {\ chi }{ n }\ right ) ^{ n - h ( x,y )} .
\ end { aligned }$$\ end { document } pry = pmutea ( x )= chinh ( x,y ) 1 - chinn - h ( x,y ) .
lemma 7 for all positive constants d , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ chi $$\ end { document } chi and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon $$\ end { document } epsilon , the function \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ r ,\ ell ,\ theta }$$\ end { document } mhbr,l,theta is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ left ( \ frac {\ theta }{ 1 + d } , \ left ( \ frac { r \ chi }{ n \ ell }\ right ) ^{\ ell } e ^{ - ( 1 +\ varepsilon )\ chi }\ right ) $$\ end { document } theta1 + d,rchinlle - ( 1 + epsilon ) chi - stable with respect to the bitwise mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }^\ mathrm { ea } $$\ end { document } pmutea with parameter \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ chi $$\ end { document } chi .
proof for any given time t , let x be the random variable associated with the number of time steps in the future that the target bitstring will be changed .
if we pick \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ kappa := \ theta /( 1 + d )$$\ end { document } kappa := theta /( 1 + d ) , then it is clear that within the next \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ kappa $$\ end { document } kappa time steps , there will be more than one change of the target bitstring if and only if \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ le \ kappa $$\ end { document } x <= kappa .
it follows from lemmas 18 and 19 that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( x \ le \ kappa \ right )&\ le e ^{ - \ theta }\ left ( \ frac { e \ theta }{\ kappa }\ right ) ^{\ kappa } = e ^{ - ( 1 + d )\ kappa }\ left ( ( 1 + d ) e \ right ) ^{\ kappa } \\&= e ^{ - d \ kappa }( 1 + d )^{\ kappa } \ le \ exp \ left ( - d \ kappa + \ kappa \ cdot \ frac { d }{ 2 }\ cdot \ frac { d + 2 }{ d + 1 }\ right ) \\&= \ exp \ left ( - \ frac {\ kappa }{ 2 }\ left ( \ frac { d ^ 2 }{ d + 1 }\ right ) \ right ) . \ end { aligned }$$\ end { document } prx <= kappa <= e - thetaethetakappakappa = e - ( 1 + d ) kappa ( 1 + d ) ekappa = e - dkappa ( 1 + d ) kappa <= exp - dkappa + kappa.d2.d + 2d + 1 = exp - kappa2d2d + 1.it suffices to pick the constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ upsilon {:=} \ frac { d ^ 2 }{ 2 ( d + 1 )}$$\ end { document } upsilon := d22 ( d + 1 ) so that with a probability of at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ 1 - e ^{ - \ upsilon \ kappa }$$\ end { document } 1 - e - upsilonkappa , there is at most one change to the target function within the next \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ kappa $$\ end { document } kappa time steps .
under that condition , it holds for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t ^{\ prime }\ in [ t , t +\ kappa ]$$\ end { document } t'in [ t,t + kappa ] and for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ in \ mathrm { b }_ r ( x ( t )) = : \ mathrm { opt }_{ t }$$\ end { document } xinbr ( x ( t ))= : optt , that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { h }( x , x ( t ^{\ prime })) = r + \ ell ^{\ prime }$$\ end { document } h ( x,x ( t '))= r + l ' for some \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell ^{\ prime }\ in \{ 0 \} \ cup [\ ell ]$$\ end { document } l'in { 0 } union [ l ] .
in the case that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell ^{\ prime }= 0 $$\ end { document } l '= 0 , e.g. the target does not move or it moves closer to x , it suffices to not flip any of the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ n - r $$\ end { document } n - r bits .
for any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon $$\ end { document } epsilon , it holds for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ n \ ge ( 1 + 1 /\ varepsilon )\ chi $$\ end { document } n >=( 1 + 1 / epsilon ) chi that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( p _\ mathrm { mut }^\ mathrm { ea } ( x ) \ in \ mathrm { b }_ r ( x ( t ^{\ prime }))\ mid \ ell ^{\ prime }= 0 \ right )&\ ge \ left ( 1 - \ frac {\ chi }{ n }\ right ) ^{ n - r } \ ge \ left ( 1 - \ frac {\ chi }{ n }\ right ) ^{\ left ( \ frac { n }{\ chi } - 1 \ right ) \ chi \ left ( 1 + \ frac {\ chi }{ n - \ chi }\ right ) } \\&\ ge e ^{ - ( 1 +\ varepsilon )\ chi } .
\ end { aligned }$$\ end { document } prpmutea ( x ) inbr ( x ( t '))| l '= 0 >= 1 - chinn - r >= 1 - chinnchi - 1chi1 + chin - chi >= e - ( 1 + epsilon ) chi.in the case that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell ^{\ prime }> 0 $$\ end { document } l '> 0 , it suffices to recover the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell ^{\ prime }$$\ end { document } l ' bits among the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r + \ ell ^{\ prime }$$\ end { document } r + l ' mismatched ones , so \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( p _\ mathrm { mut }^\ mathrm { ea } ( x ) \ in \ mathrm { b }_ r ( x ( t ^{\ prime }))\ mid \ ell ^{\ prime }> 0 \ right )&\ ge \ left ( {\ begin { array }{ c } r + \ ell ^{\ prime }\\ \ ell ^{\ prime }\ end { array }}\ right ) \ left ( \ frac {\ chi }{ n }\ right ) ^{\ ell ^{\ prime }} \ left ( 1 - \ frac {\ chi }{ n }\ right ) ^{ n - \ ell ^{\ prime }} \\&\ ge \ left ( \ frac { r + \ ell ^{\ prime }}{\ ell ^{\ prime }}\ right ) ^{\ ell ^{\ prime }}\ left ( \ frac {\ chi }{ n }\ right ) ^{\ ell ^{\ prime }} e ^{ - ( 1 +\ varepsilon )\ chi } \\&> \ left ( \ frac { r \ chi }{\ ell ^{\ prime } n }\ right ) ^{\ ell ^{\ prime }} e ^{ - ( 1 +\ varepsilon )\ chi } \ ge \ left ( \ frac { r \ chi }{\ ell n }\ right ) ^{\ ell } e ^{ - ( 1 +\ varepsilon )\ chi } .
\ end { aligned }$$\ end { document } prpmutea ( x ) inbr ( x ( t '))| l '> 0 >= r + l'l'chinl'1 - chinn - l '>= r + l'l'l'chinl'e - ( 1 + epsilon ) chi > rchil'nl'e - ( 1 + epsilon ) chi >= rchilnle - ( 1 + epsilon ) chi.note that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{ t ^{\ prime }} := \ mathrm { b }_ r ( x ( t ^{\ prime }))$$\ end { document } optt ':= br ( x ( t ')) , hence \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( p _\ mathrm { mut }^\ mathrm { ea } ( x ) \ in \ mathrm { opt }_{ t ^{\ prime }}\ right ) \ ge \ left ( \ frac { r \ chi }{\ ell n }\ right ) ^{\ ell } e ^{ - ( 1 +\ varepsilon )\ chi } = : \ rho \ end { aligned }$$\ end { document } prpmutea ( x ) inoptt '>= rchilnle - ( 1 + epsilon ) chi = : rhoand \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ r ,\ ell ,\ theta }$$\ end { document } mhbr,l,theta is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ kappa ,\ rho )$$\ end { document }( kappa,rho ) - stable with respect to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }^\ mathrm { ea } $$\ end { document } pmutea .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* it is not difficult to see that the stability condition of the function class still holds with the following relaxations : the fitness of the solutions inside the hamming ball changes when the target string moves , the fitness of the solutions outside the current hamming ball can be distributed differently , as long as they are less than the current optimal fitness , the moving step \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell $$\ end { document } l is relaxed to be sampled from any discrete distribution over \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$[\ ell ]$$\ end { document }[ l ] in each change of the target bitstring .
we will not consider these relaxations as they are not required to distinguish between the effectiveness of single - individual and population - based evolutionary algorithms .
algorithms we will compare the performance of population - based and single - individual based evolutionary algorithms .
in this section we first define these classes of algorithms .
we are considering dynamic optimisation problems and , as mentioned in the introduction and discussed by jansen and zarges [ 10 ] , it is important to clarify how the algorithms deal with change of the fitness functions , in particular if this happens during one generation .
in this paper , we consider algorithms that make use of consistent comparisons when applying on a dynamic function : when an algorithm has to make fitness comparisons on a set of solutions , it will first make a static copy of the dynamic function and evaluate the solutions on this copy .
this approach corresponds to an implementation where the necessary data to evaluate the optimisation function is collected before evaluating a set of solutions .
meanwhile the real function may have changed more or less depending on the number of solutions in the set .
we first consider the single - individual approach described in algorithm 1 .
the algorithm keeps a current search point x. in each iteration , it produces a new candidate solution \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x ^{\ prime }$$\ end { document } x ' , and compares it with the current search point using the same function .
hence , static copies of the dynamic function are made in every two time steps .
this corresponds to a frequent update of the dynamic function .
we let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut be the bitwise mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }^\ mathrm { ea } $$\ end { document } pmutea described in sect .
2.3 , and obtain the well - known \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea [ 5 ] .
however , the result can be easily generalised to other mutation operators , such as the single - bit flip operator used in the rls algorithm .
we are mostly interested in the influence of the population size , designated by the parameter \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda $$\ end { document } lambda , on the ability of a population - based algorithm to track the moving optimal region .
we focus on the non - elitist setting as described in algorithm 2 .
the algorithm uses a unary variation operator denoted by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut , no crossover operator , and an unspecified selection mechanism \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel .
the selection mechanism is any random operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel that given a population p and access to a fitness function returns one of the individuals in p. by specifying different \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut , algorithm 2 can instantiate a large number of population - based search heuristics , such as the (\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mu ,\ lambda $$\ end { document } mu,lambda ) ea. the number of search points \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda $$\ end { document } lambda produced in each round is the only parameter that appears in the description of algorithm 2 .
the (\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mu ,\ lambda $$\ end { document } mu,lambda ) ea fits within this framework by making sure that the selection in line 4 only takes into account the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mu $$\ end { document } mu best of the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda $$\ end { document } lambda search points created in the last round .
the algorithm maintains a population \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ tau $$\ end { document } ptau of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda $$\ end { document } lambda individuals which during one generation ( steps 2 - 6 ) is replaced by a newly created population \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _{\ tau + 1 }$$\ end { document } ptau + 1 of the same size .
as for the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea , we assume that the initial population \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 0 $$\ end { document } p0 is contained in the first optimal region \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{ 0 }$$\ end { document } opt0 .
each individual in the next population \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _{\ tau + 1 }$$\ end { document } ptau + 1 is created by first making a copy x of one parent individual which is selected from the current population ( step 4 selection ) , then modifying the copy using \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut operator ( step 5 , mutation ) .
when selecting individuals , the algorithm must take into account that multiple changes to the fitness function can occur during one generation .
here , we assume that the algorithm makes a static copy of the fitness function \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f _{\ tau \ lambda }$$\ end { document } ftaulambda at the beginning of each generation , i.e. at time \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau \ lambda $$\ end { document } taulambda .
the selection mechanism \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel compares all individuals in a generation using the static copy .
note that if the population size \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda $$\ end { document } lambda is too large with respect to the problem parameter \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ theta $$\ end { document } theta ( which controls the frequency of change of the dynamic function ) , then the optimal region may change several times between two consecutive generations .
hence , the population size should not be too large .
however , we will show in the next section that a sufficiently large population is also essential to keep the population within the optimal region .
the result for populations will be first shown for any finite search space and any mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut because the class of dynamic function is defined with respect to the operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut .
then we will use \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }^\ mathrm { ea } $$\ end { document } pmutea over \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\{ 0,1 \}^ n $$\ end { document }{ 0,1 } n as a specific example .
although algorithm 2 can use any selection mechanism \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel , we are looking for choices of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel that allows the algorithm to track optima efficiently .
formally , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel applied on finite populations of size \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda $$\ end { document } lambda is represented by the transition matrix \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } :[\ lambda ] \ times \ mathcal { x }^\ lambda \ rightarrow [ 0,1 ]$$\ end { document } psel :[ lambda ] xxlambda - - >[ 0,1 ] , where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } ( i \ mid p )$$\ end { document } psel ( i | p ) represents the probability of selecting individual p ( i ) , i.e. the i - th individual , of p. we also write \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x = p _\ mathrm { sel } ( p )$$\ end { document } x = psel ( p ) , e.g. in the algorithm , to express that x is sampled from the distribution over p given by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } (\ cdot , p )$$\ end { document } psel (. , p ) .
we use \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _{( i )}$$\ end { document } x ( i ) to denote the ith best individual of p , or the so - called \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( i /\ lambda )$$\ end { document }( i / lambda ) - ranked individual .
similar to [ 3 , 13 ] , we characterise \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel by the cumulative selection probability .
definition 8 ([ 13 ]) .
given a fitness function \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ f :\ mathcal { x } \ rightarrow \ mathbb { r }$$\ end { document } f : x - - > r , the cumulative selection probability \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta $$\ end { document } beta associated with selection mechanism \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel is defined on f for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma \ in ( 0,1 ]$$\ end { document } gammain ( 0,1 ] and a \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p \ in \ mathcal { x }^\ lambda $$\ end { document } pinxlambda by \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ beta (\ gamma , p ) := \ sum _{ i \ in [\ lambda ]} p _\ mathrm { sel } ( i \ mid p ) \ cdot \ left [ f ( p ( i )) \ ge f ( x _{(\ lceil \ gamma \ lambda \ rceil )}) \ right ] . \ end { aligned }$$\ end { document } beta ( gamma,p ):= sumiin [ lambda ] psel ( i | p ). f ( p ( i ))>= f ( x ([ gammalambda ])) .
informally , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma , p )$$\ end { document } beta ( gamma,p ) is the probability of selecting an individual with fitness at least as good as that of the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma $$\ end { document } gamma - ranked individual , assuming that p is sorted according to fitness values .
we are interested in a lower bound function of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma , p )$$\ end { document } beta ( gamma,p ) .
most often this lower bound is independent of p , in which case we simply write it as a function of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma $$\ end { document } gamma only , i. e. as \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma )$$\ end { document } beta ( gamma ) .
performance analysis in this section , we first show that single - individual approaches are inefficient in tracking moving optima on at least one example function of the class , precisely on \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ r ,\ ell ,\ theta }$$\ end { document } mhbr,l,theta .
then we prove a general result that an appropriately parameterised population - based algorithms can efficiently track the moving optima of any function in the class .
inefficiency of a single individual in this section , we will show that the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea spends an exponential fraction of its time outside the optimal region of a \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn function , for a sufficiently small constant b , any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c > 0 $$\ end { document } c > 0 and any \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell \ ge 1 $$\ end { document } l >= 1. that is to say the algorithm is inefficient even in tracking such a stable function .
to prove such a result , we have to analyse the behaviour of the algorithm both inside and outside the moving hamming ball : we assume that the algorithm starts at the center of the first optimal region and show that after some initial time , whenever the center of the ball moves , there is a constant probability that the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea will memorise a search point outside of the new ball ; whenever the algorithm is outside of the optimal region there is also a constant probability that the memorised search point will drift away from the optimal region ( eventually get lost ) , before an optimal solution inside the new ball is discovered .
since the changes to the function happens within an expected polynomial number steps , we can conclude that with a high probability , the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea only spends a polynomial number of time steps inside the moving hamming ball .
we start with the first argument , the behaviour of the algorithm inside the hamming ball .
we notice that the changes induced by the dynamics of the fitness function strongly drag the target away from the current memorised search point , however this does not happen in every iteration .
in every iteration , the changes by mutation drive the memorised solution away from the center of the current hamming ball , but the elitist selection also keeps the memorised solution from falling outside .
we have the following analysis of the drift .
we consider the process \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ in \ mathbb { n }}$$\ end { document }( xt ) tinn , where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t $$\ end { document } xt is the hamming distance to the border of the optimal region of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn at time t , i.e. \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t = r - \ mathrm { h }( x ^{*}( t ) , x _\ tau )$$\ end { document } xt = r - h ( x *( t ) , xtau ) .
the process starts with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t = r $$\ end { document } xt = r , e.g. exactly at the center of the hamming ball .
given \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t = i $$\ end { document } xt = i , define \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ vardelta ( i ){:=} x _{ t } - x _{ t + 1 }$$\ end { document } delta ( i ):= xt - xt + 1 , then \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbf { e }\ left [ \ vardelta ( i )\ mid x _{ t }= i \ right ] $$\ end { document } edelta ( i )| xt = i is the drift towards the border at time t and where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t = i $$\ end { document } xt = i. first of all , the dynamic now only kicks in every cn time steps in expectation .
also , the contributing drift is positive .
for example , if the dynamic kicks in , let z be the number of bits being corrected by the dynamic , then we have \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ z \ sim {{\ mathrm { hypergeo }}}( n,n - i ,\ ell )$$\ end { document } z ~ hypergeo ( n,n - i,l ) , and the contributing drift is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbf { e }\ left [ \ ell - 2z \ right ] = \ ell ( 1 - 2i / n ) > 0 $$\ end { document } el - 2z = l ( 1 - 2i / n )> 0 for any \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r / n < 1 / 2 $$\ end { document } r / n < 1 / 2 .
we now compute the drift by mutation at time t and where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t = i > 0 $$\ end { document } xt = i > 0 .
let x and y be the number of bits being corrected and being messed up respectively by the mutation , so \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ sim {{\ mathrm { bin }}}( r - i ,\ chi / n )$$\ end { document } x ~ bin ( r - i,chi / n ) , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y \ sim {{\ mathrm { bin }}}( n - ( r - i ),\ chi / n )$$\ end { document } y ~ bin ( n - ( r - i ) , chi / n ) and the two variables are independent .
note that for all integers \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ ge 0 $$\ end { document } x >= 0 , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y \ ge 0 $$\ end { document } y >= 0 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i \ ge 1 $$\ end { document } i >= 1 , it holds \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ vardelta ( i )&= ( y - x ) \ cdot \ mathbbm { 1 }_{\{ y - x \ le i \}} = y \ cdot \ mathbbm { 1 }_{\{ y \ le i + x \}} - x \ cdot \ mathbbm { 1 }_{\{ x \ ge y - i \}} \\&\ ge y \ cdot \ mathbbm { 1 }_{\{ y \ le 1 \}} - x = \ mathbbm { 1 }_{\{ y = 1 \}} - x = : \ vardelta _ 1 ( i ) .
\ end { aligned }$$\ end { document } delta ( i )=( y - x ). 1 { y - x <= i }= y.1 { y <= i + x } - x.1 { x >= y - i }>= y.1 { y <= 1 } - x = 1 { y = 1 } - x = : delta1 ( i ). thus for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i > 0 $$\ end { document } i > 0 , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ vardelta ( i )$$\ end { document } delta ( i ) stochastically dominates \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ vardelta _ 1 ( i )$$\ end { document } delta1 ( i ) and we also have \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathbf { e }\ left [ \ vardelta _ 1 ( i ) \ mid x _ t = i \ right ]&= \ mathbf { e }\ left [ \ mathbbm { 1 }_{\{ y = 1 \}} \ right ] - \ mathbf { e }\ left [ x \ right ] \\&= \ left ( {\ begin { array }{ c } n - ( r - i )\\ 1 \ end { array }}\ right ) \ left ( \ frac {\ chi }{ n }\ right ) \ left ( 1 - \ frac {\ chi }{ n }\ right ) ^{ n - ( r - i ) - 1 } - \ frac { i \ chi }{ n } \\&\ ge \ chi \ left ( \ left ( 1 - \ frac { r - i }{ n }\ right ) e ^{ - ( 1 +\ varepsilon )\ chi } - \ frac { r - i }{ n }\ right ) \\&> \ chi \ left ( \ left ( 1 - \ frac { r }{ n }\ right ) e ^{ - ( 1 +\ varepsilon )\ chi } - \ frac { r }{ n }\ right ) \\&= \ chi \ left ( \ left ( 1 - b \ right ) e ^{ - ( 1 +\ varepsilon )\ chi } - b \ right ) \ end { aligned }$$\ end { document } edelta1 ( i )| xt = i = e1 { y = 1 } - ex = n - ( r - i ) 1chin1 - chinn - ( r - i ) - 1 - ichin >= chi1 - r - ine - ( 1 + epsilon ) chi - r - in > chi1 - rne - ( 1 + epsilon ) chi - rn = chi1 - be - ( 1 + epsilon ) chi - bfor any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon > 0 $$\ end { document } epsilon > 0 .
therefore , with any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ b < 1 /( 1 + 2 e ^\ chi )$$\ end { document } b < 1 /( 1 + 2echi ) , we have that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ b \ le ( 1 - b ) e ^{ - ( 1 +\ varepsilon )\ chi }/ 2 $$\ end { document } b <=( 1 - b ) e - ( 1 + epsilon ) chi / 2 .
hence , for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i > 0 $$\ end { document } i > 0 we have at least a constant drift away from the center \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathbf { e }\ left [ \ vardelta _ 1 ( i ) \ mid x _ t = i \ right ] > \ left ( \ frac {\ chi }{ 2 \ cdot e ^{( 1 +\ varepsilon )\ chi }}\ right ) \ left ( 1 - b \ right ) = : \ delta . \ end { aligned }$$\ end { document } edelta1 ( i )| xt = i > chi2.e ( 1 + epsilon ) chi1 - b = : delta.the only position where we have a drift toward the center is the one at the border , e.g. \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t = 0 $$\ end { document } xt = 0 .
however , this is not a strong drift .
when the target bitstring does not move in the next iteration , we have \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ - \ vardelta ( 0 ) = ( x - y )\ cdot \ mathbbm { 1 }_{\{ y - x \ le 0 \}} \ le x \ cdot \ mathbbm { 1 }_{\{ x \ ge y \}} \ le x $$\ end { document } - delta ( 0 )=( x - y ). 1 { y - x <= 0 }<= x.1 { x >= y }<= x , then the negative drift is no more than \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathbf { e }\ left [ x \ right ] = \ frac { r \ chi }{ n } = : \ eta . \ end { aligned }$$\ end { document } ex = rchin = : eta.in summary , we get the drift by mutation : 1 \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathbf { e }\ left [ \ vardelta ( i ) \ cdot \ mathbbm { 1 }_{\{ x _ t > 0 \}} \ mid x _ t = i \ right ]&\ ge \ delta \ cdot \ mathbbm { 1 }_{\{ x _ t > 0 \}}\ end { aligned }$$\ end { document } edelta ( i ). 1 { xt > 0 }| xt = i >= delta.1 { xt > 0 } 2 \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathbf { e }\ left [ \ vardelta ( i ) \ cdot \ mathbbm { 1 }_{\{ x _ t = 0 \}} \ mid x _ t = i \ right ]&\ ge - \ eta \ cdot \ mathbbm { 1 }_{\{ x _ t = 0 \}} \ end { aligned }$$\ end { document } edelta ( i ). 1 { xt = 0 }| xt = i >= - eta.1 { xt = 0 } it is then suggested that the equilibrium state of the memorised search point is around the border .
furthermore , we can quantify the expected fraction of time that the search point is found at the border , using the following tool .
lemma 9 given a stochastic process \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ ge 0 }$$\ end { document }( xt ) t >= 0 over a state space \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbb { n }$$\ end { document } n , and two constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta ,\ delta \ in \ mathbb { r }_+$$\ end { document } eta,deltainr + such that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbf { e }\ left [ x _{ t + 1 } \ cdot \ mathbbm { 1 }_{\{ x _ t = 0 \}}\ mid x _ t \ right ] \ le \ eta \ cdot \ mathbbm { 1 }_{\{ x _ t = 0 \}}$$\ end { document } ext + 1.1 { xt = 0 }| xt <= eta.1 { xt = 0 } , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbf { e }\ left [ x _{ t + 1 } \ cdot \ mathbbm { 1 }_{\{ x _ t > 0 \}}\ mid x _ t \ right ] \ le ( x _ t - \ delta ) \ cdot \ mathbbm { 1 }_{\{ x _ t > 0 \}}$$\ end { document } ext + 1.1 { xt > 0 }| xt <=( xt - delta ). 1 { xt > 0 } , then for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t \ ge 1 $$\ end { document } t >= 1 \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ sum _{ i = 0 }^{ t - 1 }\ pr \ left ( x _ t = 0 \ right ) \ ge \ frac {\ delta t - x _ 0 }{\ delta +\ eta } .
\ end { aligned }$$\ end { document } sumi = 0t - 1prxt = 0 >= deltat - x0delta + eta .
proof define \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ i =\ pr \ left ( x _ i = 0 \ right ) $$\ end { document } pi = prxi = 0 .
for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t \ ge 1 $$\ end { document } t >= 1 , it holds \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathbf { e }\ left [ x _ t \ right ]&= \ mathbf { e }\ left [ \ mathbbm { 1 }_{\{ x _{ t - 1 }= 0 \}} \ cdot x _{ t }\ right ] +\ mathbf { e }\ left [ \ mathbbm { 1 }_{\{ x _{ t - 1 }> 0 \}} \ cdot x _{ t }\ right ] \\&=\ mathbf { e }\ left [ \ mathbf { e }\ left [ \ mathbbm { 1 }_{\{ x _{ t - 1 }= 0 \}} \ cdot x _{ t }\ mid x _{ t - 1 }\ right ] \ right ] +\ mathbf { e }\ left [ \ mathbf { e }\ left [ \ mathbbm { 1 }_{\{ x _{ t - 1 }> 0 \}} \ cdot x _{ t }\ mid x _{ t - 1 }\ right ] \ right ] \\&\ le \ mathbf { e }\ left [ \ eta \ cdot \ mathbbm { 1 }_{\{ x _{ t - 1 }= 0 \}} \ right ] + \ mathbf { e }\ left [ ( x _{ t - 1 } - \ delta ) \ cdot \ mathbbm { 1 }_{\{ x _{ t - 1 }> 0 \}}\ right ] \\&=\ eta p _{ t - 1 } - \ delta ( 1 - p _{ t - 1 })+\ mathbf { e }\ left [ x _{ t - 1 } \ cdot \ mathbbm { 1 }_{\{ x _{ t - 1 }> 0 \}} \ right ] \\&=\ eta p _{ t - 1 } - \ delta ( 1 - p _{ t - 1 })+\ mathbf { e }\ left [ x _{ t - 1 }\ right ] . \ end { aligned }$$\ end { document } ext = e1 { xt - 1 = 0 }. xt + e1 { xt - 1 > 0 }. xt = ee1 { xt - 1 = 0 }. xt | xt - 1 + ee1 { xt - 1 > 0 }. xt | xt - 1 <= eeta.1 { xt - 1 = 0 }+ e ( xt - 1 - delta ). 1 { xt - 1 > 0 }= etapt - 1 - delta ( 1 - pt - 1 )+ ext - 1.1 { xt - 1 > 0 }= etapt - 1 - delta ( 1 - pt - 1 )+ ext - 1.it follows that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ mathbf { e }\ left [ x _ t \ mid x _ 0 \ right ] \ le x _ 0 - t \ delta +(\ delta +\ eta )\ sum _{ i = 0 }^{ t - 1 } p _ t .
\ end { aligned }$$\ end { document } ext | x0 <= x0 - tdelta +( delta + eta ) sumi = 0t - 1pt.finally , since \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbf { e }\ left [ x _ t \ mid x _ 0 \ right ] \ ge 0 $$\ end { document } ext | x0 >= 0 \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ sum _{ i = 0 }^{ t - 1 } p _ t \ ge \ frac { t \ delta - x _ 0 }{\ delta +\ eta } .
\ end { aligned }$$\ end { document } sumi = 0t - 1pt >= tdelta - x0delta + eta .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* the following lemma considers non - negative , integer - valued stochastic processes with positive drift at most \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta $$\ end { document } eta in state 0 , and negative drift at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta $$\ end { document } delta elsewhere .
it provides a lower bound on the probability of such a process being in state 0 after some time .
lemma 10 let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ ge 0 }$$\ end { document }( xt ) t >= 0 be any stochastic process with support in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\{ 0 \}\ cup [ r ]$$\ end { document }{ 0 } union [ r ] for some fixed \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r \ in \ mathbb { n }$$\ end { document } rinn , which satisfies the properties of lemma 9 for some \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta ,\ eta \ in \ mathbb { r }_+$$\ end { document } delta,etainr + .
then for any random variable \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _ 1 \ ge \ lceil 2r /\ delta \ rceil $$\ end { document } t1 >=[ 2r / delta ] which is independent of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ ge 0 }$$\ end { document }( xt ) t >= 0 , it holds \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( x _{ t _ 1 }= 0 \ right ) \ ge \ frac {\ delta }{ 2 (\ delta +\ eta )} .
\ end { aligned }$$\ end { document } prxt1 = 0 >= delta2 ( delta + eta ) .
proof choose \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t := \ lceil 2r /\ delta \ rceil $$\ end { document } t :=[ 2r / delta ] , and define \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _ i := x _{ t _ 0 + i }$$\ end { document } yi := xt0 + i where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _ 0 := t _ 1 - t $$\ end { document } t0 := t1 - t and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t \ sim {{\ mathrm { unif }}}( \{ 0 \}\ cup [ t - 1 ])$$\ end { document } t ~ unif ({ 0 } union [ t - 1 ]) , i.e. , we consider the process \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t $$\ end { document } xt from a random starting point \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _ 0 \ ge 0 $$\ end { document } t0 >= 0 .
due to independence between \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _ 1 , t $$\ end { document } t1,t , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ ge 0 }$$\ end { document }( xt ) t >= 0 , we have \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( x _{ t _ 1 }= 0 \ right )&= \ sum _{ i = 0 }^{ t - 1 }\ pr \ left ( y _ i = 0 \ wedge t _ 0 + i = t _ 1 \ right ) \\&= \ sum _{ i = 0 }^{ t - 1 }\ pr \ left ( y _ i = 0 \ right ) \ pr \ left ( t = i \ right ) \\&= \ sum _{ i = 0 }^{ t - 1 }\ frac { 1 }{ t }\ pr \ left ( y _ i = 0 \ right ) . \ end { aligned }$$\ end { document } prxt1 = 0 = sumi = 0t - 1pryi = 0 ^ t0 + i = t1 = sumi = 0t - 1pryi = 0prt = i = sumi = 0t - 11tpryi = 0.lemma 9 applied to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( y _ t )_{ t \ ge 0 }$$\ end { document }( yt ) t >= 0 now implies \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ sum _{ i = 0 }^{ t - 1 }\ frac { 1 }{ t }\ pr \ left ( y _ i = 0 \ right ) \ ge \ frac {\ delta - y _ 0 / t }{\ delta +\ eta } \ ge \ frac {\ delta }{ 2 (\ delta +\ eta )} .
\ end { aligned }$$\ end { document } sumi = 0t - 11tpryi = 0 >= delta - y0 / tdelta + eta >= delta2 ( delta + eta ) .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* we now show that once the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea has lost track of the optimal region it will take a long time to recover .
we assume that the objective function is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn with radius \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r = bn \ ll n / 2 $$\ end { document } r = bn << n / 2 , i.e. \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ b \ le ( 1 / 2 ) - \ kappa $$\ end { document } b <=( 1 / 2 ) - kappa for some constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ kappa > 0 $$\ end { document } kappa > 0 ( note that b can depend on n ) .
the first step in this proof is to show that with not too small probability the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea ends up far away ( more specifically , in a linear distance ) from the hamming ball before recovering it. lemma 11 given \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ o \ in \{ 0,1 \}^ n $$\ end { document } oin { 0,1 } n , let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ ge 0 }$$\ end { document }( xt ) t >= 0 be a sequence of random bit strings such that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t = p _\ mathrm { mut }^\ mathrm { ea } ( x _{ t - 1 })$$\ end { document } xt = pmutea ( xt - 1 ) and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ 0 \ in \ mathrm { b }_{ r + 1 }( o )$$\ end { document } x0inbr + 1 ( o ) for some \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r = bn \ ll n / 2 $$\ end { document } r = bn << n / 2 , i.e. \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ 0 < b \ le 1 / 2 - \ kappa $$\ end { document } 0 < b <= 1 / 2 - kappa for some \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ kappa > 0 $$\ end { document } kappa > 0 .
for any \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ d \ in \ mathbb { n }_{+}$$\ end { document } dinn + , define \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _{ r , d } := \ inf \ left \{ t \ mid \ mathrm { h }( x _ t,o ) \ le r \ text { or } \ mathrm { h }( x _ t,o )\ ge r + d \ right \} $$\ end { document } tr,d := inft | h ( xt,o )<= rorh ( xt,o )>= r + d. it holds that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ pr \ left ( \ mathrm { h }( x _{ t _{ r , d }} , o ) \ le r \ right ) = \ mathord {\ text { o }}\ mathord {\ left ( \ max \{ r , \ log n \}/ n \ right ) }$$\ end { document } prh ( xtr,d,o )<= r = omax { r,logn }/ n where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ d = \ varepsilon n $$\ end { document } d = epsilonn for a not too large constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon > 0 $$\ end { document } epsilon > 0 .
proof we begin with considering another random sequence \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _ 0,y _ 1,y _ 2,y _ 3 ,\ ldots $$\ end { document } y0,y1,y2,y3 ,.. .
where for each \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t \ in \ mathbb { n }$$\ end { document } tinn the point \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _ t $$\ end { document } yt is created by flipping one randomly selected bit in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _{ t - 1 }$$\ end { document } yt - 1 .
let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t ^{\ prime }_{ r , d }$$\ end { document } tr,d ' be defined as \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _{ r , d }$$\ end { document } tr,d but with respect to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _ t $$\ end { document } yt instead of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _ t $$\ end { document } xt. let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ x := \ pr \ left ( \ mathord {\ mathrm { h }}\ mathord {\ left ( y _{ t ^{\ prime }_{ r , d }} , o \ right ) } \ le r \ mid \ mathord {\ mathrm { h }}\ mathord {\ left ( y _ 0 , o \ right ) } = x \ right ) $$\ end { document } px := prhytr,d ' , o <= r | hy0,o = x , i. e. , the probability to enter the hamming ball before reaching distance d given the process is started with hamming distance x. note that , for symmetry reasons , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ x $$\ end { document } px is well defined , i. e. , the probability does only depend on the hamming distance x and not the specific choice of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _ 0 $$\ end { document } y0. by definition of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t ^{\ prime }_{ r , d }$$\ end { document } tr,d ' we have \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ x = 1 $$\ end { document } px = 1 for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ le r $$\ end { document } x <= r and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ x = 0 $$\ end { document } px = 0 for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ ge r + d $$\ end { document } x >= r + d. for all other values of x , i. e. , for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ in \{ r + 1,r + 2 ,\ ldots , n - r - 1 \}$$\ end { document } xin { r + 1,r + 2 ,... , n - r - 1 } we have \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } p _ x = \ left ( \ frac { n - x }{ n }\ right ) p _{ x + 1 } + \ left ( \ frac { x }{ n }\ right ) p _{ x - 1 } \ end { aligned }$$\ end { document } px = n - xnpx + 1 + xnpx - 1by definition of the sequence \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _ t $$\ end { document } yt because with probability \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( n - x )/ n $$\ end { document }( n - x )/ n the hamming distance to the centre of the hamming ball o is increased by 1 and with the remaining probability x / n it is decreased by 1 .
if we pessimistically assume that the probability to move towards the hamming ball is always equal to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( d + r - 1 )/ n $$\ end { document }( d + r - 1 )/ n we obtain an upper bound on \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ x $$\ end { document } px and are in the situation of the gambler 's ruin problem with initial funds \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ s _ a = x - r $$\ end { document } sa = x - r and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ s _ b = d + r - x $$\ end { document } sb = d + r - x , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ a = ( n - d - r + 1 )/ n $$\ end { document } pa =( n - d - r + 1 )/ n , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ b = ( d + r - 1 )/ n $$\ end { document } pb =( d + r - 1 )/ n and the probability to be ruined \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } q ( r , d , x ) = \ frac {\ left ( \ frac { d + r - 1 }{ n - d - r + 1 }\ right ) ^{ x - r } - \ left ( \ frac { d + r - 1 }{ n - d - r + 1 }\ right ) ^{ d }}{ 1 - \ left ( \ frac { d + r - 1 }{ n - d - r + 1 }\ right ) ^{ d }} \ end { aligned }$$\ end { document } q ( r,d,x )= d + r - 1n - d - r + 1x - r - d + r - 1n - d - r + 1d1 - d + r - 1n - d - r + 1dgives an upper bound on the probability to enter the hamming ball before reaching distance d when starting with hamming distance x to the centre of the hamming ball .
we consider the probability q ( r , d , x ) for different values of r , d and x. we are interested in the results for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ d = \ mathord {\ vartheta }\ mathord {\ left ( n \ right ) }$$\ end { document } d = thetan and consider for this \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ d = \ varepsilon n $$\ end { document } d = epsilonn where we chose the constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon > 0 $$\ end { document } epsilon > 0 such that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ d + r \ le ( n / 2 ) - \ delta n $$\ end { document } d + r <=( n / 2 ) - deltan for some positive constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta $$\ end { document } delta .
it is clear that due to the upper bound on r such a constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon $$\ end { document } epsilon exists .
it is not difficult to see that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lim _{ n \ rightarrow \ infty } q ( r,d,r + 1 )=\ mathord {\ vartheta }\ mathord {\ left ( ( r + d )/ n \ right ) }$$\ end { document } limn - - > infinityq ( r,d,r + 1 )= theta ( r + d )/ n. for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r =\ mathord {\ vartheta }\ mathord {\ left ( n \ right ) }$$\ end { document } r = thetan this is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathord {\ vartheta }\ mathord {\ left ( 1 \ right ) }$$\ end { document } theta1 and the best bound we can obtain .
for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r =\ mathord {\ text { o }}\ mathord {\ left ( n \ right ) }$$\ end { document } r = on we need to be more precise .
we begin with the case \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r = \ mathord {\ text { o }}\ mathord {\ left ( n \ right ) }$$\ end { document } r = on and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r = \ mathord {\ varomega }\ mathord {\ left ( \ log n \ right ) }$$\ end { document } r = omegalogn .
for this setting we consider \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ q ( r , \ log n , r + 1 )$$\ end { document } q ( r,logn,r + 1 ) and know that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lim _{ n \ rightarrow \ infty } q ( r , \ log n , r + 1 ) = \ mathord {\ vartheta }\ mathord {\ left ( r / n \ right ) }$$\ end { document } limn - - > infinityq ( r,logn,r + 1 )= thetar / n holds .
now we consider \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ q ( r , \ varepsilon n , r +\ log n )$$\ end { document } q ( r,epsilonn,r + logn ) and see that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lim _{ n \ rightarrow \ infty } q ( r , \ varepsilon n , r +\ log n ) = \ mathord {\ text { o }}\ mathord {\ left ( r / n \ right ) }$$\ end { document } limn - - > infinityq ( r,epsilonn,r + logn )= or / n holds .
finally , for the case \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r = \ mathord {\ omega }\ mathord {\ left ( \ log n \ right ) }$$\ end { document } r = omegalogn , we also consider \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ q ( r , \ log n , r + 1 )$$\ end { document } q ( r,logn,r + 1 ) and know that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lim _{ n \ rightarrow \ infty } q ( r , \ log n , r + 1 ) = \ mathord {\ vartheta }\ mathord {\ left ( (\ log n )/ n \ right ) }$$\ end { document } limn - - > infinityq ( r,logn,r + 1 )= theta ( logn )/ n holds .
now we consider \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ q ( r , \ varepsilon n , r +\ log n )$$\ end { document } q ( r,epsilonn,r + logn ) and see that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lim _{ n \ rightarrow \ infty } q ( r , \ varepsilon n , 2r ) = \ mathord {\ text { o }}\ mathord {\ left ( (\ log n )/ n \ right ) }$$\ end { document } limn - - > infinityq ( r,epsilonn,2r )= o ( logn )/ n holds .
together , we have \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _{ r + 1 } = \ mathord {\ text { o }}\ mathord {\ left ( \ max \{ r , \ log n \}/ n \ right ) }$$\ end { document } pr + 1 = omax { r,logn }/ n for all values of r and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ d = \ varepsilon n $$\ end { document } d = epsilonn .
since the sequence \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ y _ t $$\ end { document } yt corresponds to ' local mutations' this proves the claim for random local search .
we generalise the statement to the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea in the following way .
we can express a standard bit mutation as a process where first a random number \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ k \ in \{ 0,1,2 ,\ ldots , n \}$$\ end { document } kin { 0,1,2 ,... , n } is chosen and then k bits are selected uniformly at random to be flipped .
the case \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ k = 0 $$\ end { document } k = 0 does not flip any bit and can be ignored .
the case \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ k = 1 $$\ end { document } k = 1 is covered by the analysis for rls .
for larger \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ k =\ mathord {\ text { o }}\ mathord {\ left ( \ log n \ right ) }$$\ end { document } k = ologn we observe that such a step is very similar to a sequence of k steps where exactly 1 bit is flipped .
the difference does not change the limits we considered above .
since in one standard bit mutation k bits flip with probability \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathord {\ vartheta }\ mathord {\ left ( 1 / k !\ right ) }$$\ end { document } theta1 / k !
we can ignore steps where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathord {\ omega }\ mathord {\ left ( \ log n \ right ) }$$\ end { document } omegalogn bits flips since they contribute too little to change the asymptotic result .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* theorem 12 on \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn with any constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ b \ in ( 0 , 1 /( 1 + 2e ))$$\ end { document } bin ( 0,1 /( 1 + 2e )) , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c > 0 $$\ end { document } c > 0 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell > 0 $$\ end { document } l > 0 the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea with mutation rate 1 / n will spend only an exponentially small proportion of its time in optimal regions .
proof we assume the process starts inside the first hamming ball , and consider the process as \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( x _ t )_{ t \ ge 0 }$$\ end { document }( xt ) t >= 0 as described before in lemma 9 .
for the standard mutation , we have the drifts according to eqs .
1 and 2 are \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta = ( 1 - b )/ 2e $$\ end { document } delta =( 1 - b )/ 2e and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta = b $$\ end { document } eta = b. applying lemma 10 gives that after \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ r /( 2 \ delta ) = 2ebn /( 1 - b ) = \ vartheta ( n )$$\ end { document } r /( 2delta )= 2ebn /( 1 - b )= theta ( n ) time steps , whenever the center of the hamming ball is moved , it holds that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ pr \ left ( \ mathrm { h }( x ^{*}( t ) , x _\ tau ) = r \ right ) \ ge \ delta /(\ eta + \ delta ) = ( 1 - b )/( 2 ( 1 - b + 2eb ))$$\ end { document } prh ( x *( t ) , xtau )= r >= delta /( eta + delta )=( 1 - b )/( 2 ( 1 - b + 2eb )) .
conditioned on this event , the probability that the dynamic move \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x ^{*}( t + 1 )$$\ end { document } x *( t + 1 ) so that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _\ tau \ notin \ mathrm { b }_ r ( x ^{*}( t + 1 ))$$\ end { document } xtaunot - inbr ( x *( t + 1 )) is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ pr \ left ( l - 2z \ ge 1 \ right ) = \ pr \ left ( z \ le \ ell / 2 \ right ) $$\ end { document } prl - 2z >= 1 = prz <= l / 2 where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ z \ sim {{\ mathrm { hypergeo }}}( n,r ,\ ell )$$\ end { document } z ~ hypergeo ( n,r,l ) , e.g. the number of bit positions being corrected by the dynamic ( see the definition of z before lemma 9 ) .
therefore , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathbf { e }\ left [ z \ right ] = \ ell r / n = b \ ell $$\ end { document } ez = lr / n = bl and by markov 's inequality and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ b < 1 /( 1 + 2e )$$\ end { document } b < 1 /( 1 + 2e ) it holds that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( x ^{*}( t + 1 ) , x _\ tau > r \ right )&\ ge \ pr \ left ( \ mathrm { h }( x ^{*}( t ) , x _\ tau ) = r \ right ) \ left ( 1 - \ pr \ left ( z > \ ell / 2 \ right ) \ right ) \\&\ ge \ pr \ left ( \ mathrm { h }( x ^{*}( t ) , x _\ tau ) = r \ right ) \ left ( 1 - 2 \ mathbf { e }\ left [ z \ right ] /\ ell \ right ) \\&\ ge \ frac {( 1 - b )( 1 - 2b )}{ 2 ( 1 - b + 2eb )} = : p _ 1 > \ frac { 2e - 1 }{ 4 ( 2e + 1 )} > 0 .
\ end { aligned }$$\ end { document } prx *( t + 1 ) , xtau > r >= prh ( x *( t ) , xtau )= r1 - prz > l / 2 >= prh ( x *( t ) , xtau )= r1 - 2ez / l >=( 1 - b )( 1 - 2b ) 2 ( 1 - b + 2eb )= : p1 > 2e - 14 ( 2e + 1 )> 0.when the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _\ tau $$\ end { document } xtau is outside of the current hamming ball , it follows from lemma 11 that there is a probability of at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 2 = 1 - \ mathord {\ text { o }}\ mathord {\ left ( r / n \ right ) } = 1 - \ mathord {\ text { o }}\ mathord {\ left ( b \ right ) } > 0 $$\ end { document } p2 = 1 - or / n = 1 - ob > 0 that the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea reaches linear hamming distance to the hamming ball before finding its way back to it. application of the negative drift theorem [ 17 ] yields that the probability to find the way back into the optimal region within \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ 2 ^{ cn }$$\ end { document } 2cn steps is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathord {\ text { o }}\ mathord {\ left ( e ^{ - n }\ right ) }$$\ end { document } oe - n for a sufficiently small constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c > 0 $$\ end { document } c > 0 .
we have just show that in every \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ vartheta ( n )$$\ end { document } theta ( n ) time steps , whenever a change occurs to the target bitstring there is a probability of at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 1 p _ 2 ( 1 - e ^{ - \ varomega ( n )})$$\ end { document } p1p2 ( 1 - e - omega ( n )) that the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea will lose track of the optimal region where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 1 $$\ end { document } p1 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 2 $$\ end { document } p2 are constants .
applying this argument n times ( a change occurs approximately every cn time steps ) , we conclude that with an overwhelmingly high probability , the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea will spend no more than \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathord {\ text { o }}\ mathord {\ left ( n ^ 3 \ right ) }$$\ end { document } on3 time steps within the optimal region of the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn function .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* efficiency of non - elitist , population - based algorithms theorem 13 , which is the main result in this section , gives conditions under which the non - elitist , population - based algorithm 2 tracks the optimal regions of dynamic functions efficiently .
we show that these conditions can be satisfied for the moving hamming - balls function \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn for any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ b \ in ( 0,1 )$$\ end { document } bin ( 0,1 ) .
theorem 13 if there are constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho ,\ delta > 0 $$\ end { document } rho,delta > 0 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma _ 0 \ in ( 0,1 )$$\ end { document } gamma0in ( 0,1 ) such that f is a \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ lambda ,\ rho )$$\ end { document }( lambda,rho ) - stable dynamic function wrt .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }$$\ end { document } pmut with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda =\ varomega ( n )$$\ end { document } lambda = omega ( n ) , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel satisfies \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma )\ ge \ gamma ( 1 +\ delta )/\ rho $$\ end { document } beta ( gamma )>= gamma ( 1 + delta )/ rho for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma \ in ( 0 ,\ gamma _ 0 ]$$\ end { document } gammain ( 0,gamma0 ] , then algorithm 2 initialised with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 0 \ subset \ mathrm { opt }_{ 0 }$$\ end { document } p0subsetopt0 tracks the optima of f efficiently .
condition 1 of the theorem requires that the optimal region of the function does not move too much relatively to the variation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut during one generation .
the population size \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda $$\ end { document } lambda is a parameter of the algorithm which can be chosen freely .
so if the function is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ kappa ,\ rho )$$\ end { document }( kappa,rho ) - stable , then the first condition can be satisfied by setting population size \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda =\ kappa $$\ end { document } lambda = kappa .
condition 2 requires that the selection mechanism \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel }$$\ end { document } psel induces a sufficiently high selective pressure .
note that increasingly high selective pressure is required for decreasing values of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho $$\ end { document } rho , where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho $$\ end { document } rho is the probability of recovering the optimal search region via mutation ( see definition 4 ). fig. 2 illustration of lemmas 14 and 15 the central argument in the analysis is illustrated in fig. 2. it follows from the stability - assumption that any search point in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda can be mutated into \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda + i }$$\ end { document } opttaulambda + i for any \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i \ in [\ lambda ]$$\ end { document } iin [ lambda ] with probability at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho $$\ end { document } rho .
hence , if the algorithm selects a search point in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda with probability \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma _ 0 )$$\ end { document } beta ( gamma0 ) , then the offspring belongs to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda + i }$$\ end { document } opttaulambda + i with probability at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma _ 0 )\ rho \ ge \ gamma _ 0 ( 1 +\ delta )$$\ end { document } beta ( gamma0 ) rho >= gamma0 ( 1 + delta ) .
this argument is invoked in both of the two steps of the analysis .
lemma 14 assume that conditions 1 and 2 of theorem 13 hold .
then for any \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau \ in \ mathbb { n }$$\ end { document } tauinn , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ i \ in [\ lambda ]$$\ end { document } iin [ lambda ] , if \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$| p _{\ tau }\ cap \ mathrm { opt }_{\ tau \ lambda }|\ ge \ gamma _ 0 \ lambda $$\ end { document }| ptauintersectionopttaulambda |>= gamma0lambda , then any offspring in generation \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau + 1 $$\ end { document } tau + 1 belongs to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda + i }$$\ end { document } opttaulambda + i with probability at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma _ 0 ( 1 +\ delta )$$\ end { document } gamma0 ( 1 + delta ) .
proof the algorithm produces an individual in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda + i }$$\ end { document } opttaulambda + i if the algorithm selects an individual in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda and mutates this individual into \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda + i }$$\ end { document } opttaulambda + i. the probability of this event is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma _ 0 )\ rho \ ge ( 1 +\ delta )\ gamma _ 0 $$\ end { document } beta ( gamma0 ) rho >=( 1 + delta ) gamma0 .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* lemma 15 , which is the first step of the analysis , implies that in every generation \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau \ in \ mathbb { n }$$\ end { document } tauinn , a large fraction of the population \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ tau $$\ end { document } ptau belongs to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda .
this can be shown inductively by arguing using lemma 14 that if many individuals in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ tau $$\ end { document } ptau belong to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda , then whp .
many individuals in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _{\ tau + 1 }$$\ end { document } ptau + 1 belong to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{(\ tau + 1 )\ lambda }$$\ end { document } opt ( tau + 1 ) lambda .
knowing that many individuals in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ tau $$\ end { document } ptau belong to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda for every generation \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau $$\ end { document } tau gives us some control on the dynamics of the population .
however it does not imply that the dynamic performance measure in definition 3 is satisfied because the individuals in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda may not necessarily have been optimal when they were generated .
a second step in the analysis is therefore required , showing that if sufficiently many individuals in population \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _{\ tau }$$\ end { document } ptau belong to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{\ tau \ lambda }$$\ end { document } opttaulambda , then many offspring in generation \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau + 1 $$\ end { document } tau + 1 were optimal at the time they were generated .
this second step is contained in the proof of theorem 13 .
lemma 15 assume that conditions 1 and 2 of theorem 13 hold .
then for any generation \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau \ in \ mathbb { n }$$\ end { document } tauinn , if \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$| p _{\ tau }\ cap \ mathrm { opt }_{\ tau \ lambda }|\ ge \ gamma _ 0 \ lambda $$\ end { document }| ptauintersectionopttaulambda |>= gamma0lambda , then \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( \ left | p _{\ tau + 1 }\ cap \ mathrm { opt }_{(\ tau + 1 )\ lambda }\ right | \ ge \ gamma _ 0 \ lambda \ right ) \ ge 1 - e ^{ - \ varomega (\ lambda )} .
\ end { aligned }$$\ end { document } prptau + 1intersectionopt ( tau + 1 ) lambda >= gamma0lambda >= 1 - e - omega ( lambda ) .
proof by lemma 14 , any offspring in generation \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau + 1 $$\ end { document } tau + 1 belongs to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{(\ tau + 1 )\ lambda }$$\ end { document } opt ( tau + 1 ) lambda independently with probability \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma ( 1 +\ delta )$$\ end { document } gamma ( 1 + delta ) .
hence , by a chernoff bound , the probability that less than \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma _ 0 \ lambda $$\ end { document } gamma0lambda offspring belongs to \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{(\ tau + 1 )\ lambda }$$\ end { document } opt ( tau + 1 ) lambda is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ e ^{ - \ varomega (\ lambda )}$$\ end { document } e - omega ( lambda ) .
we are now in position to prove the main result of this section .
proof of theorem 13 we say that generation \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ tau $$\ end { document } tau fails if \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$| p _\ tau \ cap \ mathrm { opt }_{\ tau \ lambda }|\ ge \ gamma _ 0 \ lambda $$\ end { document }| ptauintersectionopttaulambda |>= gamma0lambda and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$| p _{\ tau + 1 }\ cap \ mathrm { opt }_{(\ tau + 1 )\ lambda }|< \ gamma _ 0 \ lambda $$\ end { document }| ptau + 1intersectionopt ( tau + 1 ) lambda |< gamma0lambda. by lemma 15 and a union bound , the probability that any of the first \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ e ^{ c \ lambda }/\ lambda $$\ end { document } eclambda / lambda generations fails is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ e ^{ - \ varomega (\ lambda )}$$\ end { document } e - omega ( lambda ) , assuming that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c > 0 $$\ end { document } c > 0 is a sufficiently small constant. by lemma 2 and assuming no failure , any individual \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x _{ i }$$\ end { document } xi with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda < i < e ^{ c \ lambda }$$\ end { document } lambda < i < eclambda belongs to the optimal region \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { opt }_{ i }$$\ end { document } opti with probability at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma _ 0 ( 1 +\ delta )$$\ end { document } gamma0 ( 1 + delta ). by the definition of the algorithm , individuals within the same generation are produced independently .
during any time interval \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( t,t +\ lambda )$$\ end { document }( t,t + lambda ) where \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t ,\ lambda < t < e ^{ c \ lambda }$$\ end { document } t,lambda < t < eclambda , at least \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda / 2 $$\ end { document } lambda / 2 individuals are produced in the same generation , and hence independently .
it therefore holds by a chernoff bound that for any time interval with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda < t < e ^{ c \ lambda }$$\ end { document } lambda < t < eclambda ,\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( \ sum _{ i = t }^{ t +\ lambda }\ mathbbm { 1 }_{\{ x _ i \ in \ mathrm { opt }_{ i }\}} \ ge \ gamma _ 0 \ lambda / 2 \ right ) \ ge 1 - e ^{ - \ varomega (\ lambda )} .
\ end { aligned }$$\ end { document } prsumi = tt + lambda1 { xiinopti }>= gamma0lambda / 2 >= 1 - e - omega ( lambda ). the theorem now follows by taking into account the failure probability with a union bound , and choosing the parameters \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ t _ 0 =\ lambda , \ ell =\ lambda ,$$\ end { document } t0 = lambda,l = lambda , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c ^{\ prime }=\ gamma _ 0 / 2 $$\ end { document } c '= gamma0 / 2 in definition 3 .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* theorem 13 implies that with a sufficiently slow dynamic , e.g. \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ kappa = cn $$\ end { document } kappa = cn for any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c > 0 $$\ end { document } c > 0 , the population - based algorithm can efficiently track the moving optima of the function , given that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel induces a sufficiently strong selective pressure .
we now show that given any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho \ in ( 0 , 1 )$$\ end { document } rhoin ( 0,1 ) , it is possible to parameterise many selection mechanisms so that they satisfy this requirement on \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel .
the selection mechanisms are : in k - tournament selection , k individuals are sampled uniformly at random with replacement from the population , and the fittest of these individuals is returned .
in \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mu ,\ lambda )$$\ end { document }( mu,lambda ) - selection , parents are sampled uniformly at random among the fittest \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mu $$\ end { document } mu individuals in the population .
a function \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ alpha :\ mathbb { r }\ rightarrow \ mathbb { r }$$\ end { document } alpha : r - - > r is a ranking function [ 8 ] if \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ alpha ( x )\ ge 0 $$\ end { document } alpha ( x )>= 0 for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ in [ 0,1 ]$$\ end { document } xin [ 0,1 ] , and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ int _ 0 ^ 1 \ alpha ( x )\,\ mathrm { d } x = 1 $$\ end { document } integral01alpha ( x ) dx = 1 .
in ranking selection with ranking function \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ alpha $$\ end { document } alpha , the probability of selecting individuals ranked \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma $$\ end { document } gamma or better is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ int _ 0 ^\ gamma \ alpha ( x )\,\ mathrm { d } x $$\ end { document } integral0gammaalpha ( x ) dx. linear ranking selection uses \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ alpha ( x ) := \ eta ( 1 - 2x )+ 2x $$\ end { document } alpha ( x ):= eta ( 1 - 2x )+ 2x for some \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta \ in ( 1,2 ]$$\ end { document } etain ( 1,2 ] .
exponential ranking selection uses \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ alpha ( x ):=\ eta e ^{\ eta ( 1 - x )}/( e ^\ eta - 1 )$$\ end { document } alpha ( x ):= etaeeta ( 1 - x )/( eeta - 1 ) for some \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta > 0 $$\ end { document } eta > 0 .
the following theorem shows how these selection mechanisms can be parameterised to satisfy the second requirement of theorem 13 , and hence ensure that algorithm 2 tracks the moving optima of any \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ lambda ,\ rho )$$\ end { document }( lambda,rho ) - stable function with respect to the mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut } $$\ end { document } pmut .
theorem 16 for any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho \ in ( 0,1 )$$\ end { document } rhoin ( 0,1 ) , let f be any \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ lambda ,\ rho )$$\ end { document }( lambda,rho ) - stable function wrt .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }$$\ end { document } pmut for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda =\ varomega ( n )$$\ end { document } lambda = omega ( n ) .
if there is a constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta > 0 $$\ end { document } delta > 0 such that algorithm 2 initialised with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 0 \ subset \ mathrm { opt }_{ 0 }$$\ end { document } p0subsetopt0 , and selection mechanism \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel either k - tournament selection with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ k \ ge ( 1 +\ delta )/\ rho $$\ end { document } k >=( 1 + delta )/ rho , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mu ,\ lambda )$$\ end { document }( mu,lambda ) - selection with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda /\ mu \ ge ( 1 +\ delta )/\ rho $$\ end { document } lambda / mu >=( 1 + delta )/ rho , linear ranking selection with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta \ ge ( 1 + \ delta )/\ rho $$\ end { document } eta >=( 1 + delta )/ rho , or exponential ranking selection with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta \ ge ( 1 +\ delta )/\ rho $$\ end { document } eta >=( 1 + delta )/ rho , then the algorithm tracks the optima of f efficiently .
proof the result follows from theorem 13 if we can show that there exist constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta ^{\ prime }> 0 $$\ end { document } delta '> 0 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma _ 0 \ in ( 0,1 )$$\ end { document } gamma0in ( 0,1 ) such that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma )\ ge ( 1 +\ delta ^{\ prime })\ gamma /\ rho $$\ end { document } beta ( gamma )>=( 1 + delta ') gamma / rho for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma \ in ( 0 ,\ gamma _ 0 ]$$\ end { document } gammain ( 0,gamma0 ] .
the results for k - tournament , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mu ,\ lambda )$$\ end { document }( mu,lambda ) - selection and linear ranking follow from lemmas 5 , 6 and 7 from [ 13 ] with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho $$\ end { document } rho in place of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _ 0 $$\ end { document } p0 .
for exponential ranking , we notice that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ beta (\ gamma )&\ ge \ int _{ 0 }^\ gamma \ frac {\ eta e ^{\ eta ( 1 - x )}\,\ mathrm { d } x }{ e ^\ eta - 1 } = \ left ( \ frac { e ^\ eta }{ e ^{\ eta } - 1 }\ right ) \ left ( 1 - \ frac { 1 }{ e ^{\ eta \ gamma }}\ right ) \ ge 1 - \ frac { 1 }{ 1 + \ eta \ gamma } , \ end { aligned }$$\ end { document } beta ( gamma )>= integral0gammaetaeeta ( 1 - x ) dxeeta - 1 = eetaeeta - 11 - 1eetagamma >= 1 - 11 + etagamma,the result then follows similarly to k - tournament as in the proof of lemma 5 in [ 13 ] with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta $$\ end { document } eta in place of k ( equations ( 3 ) and ( 4 ) in [ 13 ] show that \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ beta (\ gamma ) \ ge 1 - 1 /( 1 +\ gamma k )$$\ end { document } beta ( gamma )>= 1 - 1 /( 1 + gammak ) , then the constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ gamma _ 0 $$\ end { document } gamma0 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta ^{\ prime }$$\ end { document } delta ' are shown to exist given the condition on k ) .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* finally , we apply theorem 16 to show that population - based eas can track the optima of the example moving hamming ball function efficiently .
note that the parameter \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta $$\ end { document } eta in linear ranking selection can only take values in the interval ( 1 , 2 ] .
the conditions of theorem 16 can therefore only be satisfied if \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ rho > 1 / 2 $$\ end { document } rho > 1 / 2 , i.e. , the optimal regions can only change slightly .
for the last part of the paper , we therefore exclude linear ranking selection .
corollary 17 for any constants \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ delta > 0 , b \ in ( 0,1 )$$\ end { document } delta > 0,bin ( 0,1 ) , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ c > 0 $$\ end { document } c > 0 , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ d > 0 $$\ end { document } d > 0 and \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ ell \ ge 1 $$\ end { document } l >= 1 , algorithm 2 with the bitwise mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }^\ mathrm { ea } $$\ end { document } pmutea for \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ chi = 1 $$\ end { document } chi = 1 , with population size \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda = cn /( 2 ( 1 + d ))$$\ end { document } lambda = cn /( 2 ( 1 + d )) , and selection mechanism \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { sel } $$\ end { document } psel either k - tournament selection with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ k \ ge ( 1 +\ delta ) 3 (\ ell / b )^{\ ell }$$\ end { document } k >=( 1 + delta ) 3 ( l / b ) l , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$(\ mu ,\ lambda )$$\ end { document }( mu,lambda ) - selection with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ lambda /\ mu \ ge ( 1 +\ delta ) 3 (\ ell / b )^{\ ell }$$\ end { document } lambda / mu >=( 1 + delta ) 3 ( l / b ) l , exponential ranking selection with \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ eta \ ge ( 1 +\ delta ) 3 (\ ell / b )^{\ ell }$$\ end { document } eta >=( 1 + delta ) 3 ( l / b ) l. can efficiently track the moving optima of \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn. proof it follows from lemma 7 that for any constant \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon > 0 $$\ end { document } epsilon > 0 , \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ mathrm { mhb }^{ bn ,\ ell , cn }$$\ end { document } mhbbn,l,cn is \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ left ( \ frac { cn }{ 1 + d } , ( b /\ ell )^{\ ell } e ^{ - ( 1 +\ varepsilon )}\ right ) $$\ end { document } cn1 + d ,( b / l ) le - ( 1 + epsilon ) - stable with respect to the mutation operator \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ p _\ mathrm { mut }^\ mathrm { ea } $$\ end { document } pmutea .
since \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ e ^{ - ( 1 +\ varepsilon )}> 1 / 3 $$\ end { document } e - ( 1 + epsilon )> 1 / 3 for a sufficiently small \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ varepsilon $$\ end { document } epsilon , the function is also \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ left ( \ frac { cn }{ 1 + d },( 1 / 3 )( b /\ ell )^{\ ell }\ right ) $$\ end { document } cn1 + d ,( 1 / 3 )( b / l ) l - stable .
the result then follows by applying theorem 16 .
\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ square $$\ end { document }* conclusion this paper has considered the frequently stated intuition that evolutionary algorithms maintaining a population of diverse solutions can be more resilient to dynamic changes in the objective function than algorithms maintaining single solutions .
we have described a general class of fitness functions where population - based evolutionary algorithms outperform single - individual evolutionary algorithms .
we have proved that for this function class , single - individual approaches , such as the \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$( 1 + 1 )$$\ end { document }( 1 + 1 ) ea and rls , have a constant risk of losing the optimal solution region at any given time .
moreover , these single - individual algorithms not only lose the optimal region with constant probability , but are also likely to drift away from the optimal region subsequently .
on the other hand , assuming a not too high frequency of change , we describe sufficient conditions such that a non - elitist population - based evolutionary algorithm will remain within the optimal region with overwhelmingly high probability .
our analysis covers a range of the most commonly used selection mechanisms , and we provide appropriate parameter settings for each of them .
furthermore , the success of the population - based evolutionary algorithm does not rely on an explicit diversity mechanism .
our analysis gives further explanations of how and why populations can be essential and widely used in dynamic optimisation .
as future work , we would like to investigate further the influence of population settings within this class of dynamic functions , such as elitist populations , the necessary condition for the population size with respect to the frequency and magnitude of changes and how a population could rebuild itself after losing a few optimal solutions .
appendix lemma 18 ( theorem 5.4 in [ 16 ]) .
let \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$ x \ sim {{\ mathrm { pois }}}(\ theta )$$\ end { document } x ~ pois ( theta ) , then for all \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ theta > x > 0 $$\ end { document } theta > x > 0 \ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ pr \ left ( x \ le x \ right ) \ le e ^{ - \ theta }\ left ( \ frac { e \ theta }{ x }\ right ) ^ x .
\ end { aligned }$$\ end { document } prx <= x <= e - thetaethetaxx .
lemma 19 ( inequality ( 3 ) in [ 21 ]).\ documentclass [ 12pt ]{ minimal } \ usepackage { amsmath } \ usepackage { wasysym } \ usepackage { amsfonts } \ usepackage { amssymb } \ usepackage { amsbsy } \ usepackage { mathrsfs } \ usepackage { upgreek } \ setlength {\ oddsidemargin }{ - 69pt } \ begin { document }$$\ begin { aligned } \ forall x \ ge 0 \ quad 1 + x \ le \ exp \ left ( \ frac { x }{ 2 }\ cdot \ frac { x + 2 }{ x + 1 }\ right ) . \ end { aligned }$$\ end { document } for - allx >= 01 + x <= expx2.x + 2x + 1 .
the research leading to these results has received funding from the european union seventh framework programme ( fp7 / 2007 - 2013 ) under grant agreement no 618091 ( sage ) , and is based upon work from cost action ca15140 ' improving applicability of nature - inspired optimisation by joining theory and practice ( imappnio )' .
references 1 .
branke , j. , wang , w. : theoretical analysis of simple evolution strategies in quickly changing environments .
in : proceedings of the 5th annual conference on genetic and evolutionary computation , gecco'03 , pp .
537 - 548 .
( 2003 ) 2 .
dang , d .
- c. , jansen , t. , lehre , p.k. : populations can be essential in dynamic optimisation .
in : proceedings of the 17th annual conference on genetic and evolutionary computation conference , gecco'15 , pp .
1407 - 1414 .
acm ( 2015 ) 3 .
dang d - c lehre pk runtime analysis of non - elitist populations : from classical optimisation to partial information algorithmica 2016 75 3 428 461 10.1007 / s00453 - 015 - 0103 - x 4 .
droste , s. : analysis of the ( 1 + 1 ) ea for a dynamically bitwise changing onemax .
in : proceedings of the 2003 international conference on genetic and evolutionary computation , gecco'03 , pp .
909 - 921 .
springer ( 2003 ) 5 .
droste s jansen t wegener i on the analysis of the ( 1 + 1 ) evolutionary algorithm theor. comput. sci. 2002 276 51 81 10.1016 / s0304 - 3975 ( 01 ) 00182 - 7 6 .
droste s jansen t wegener i upper and lower bounds for randomized search heuristics in black - box optimization theory comput. syst .
2006 39 4 525 544 10.1007 / s00224 - 004 - 1177 - z 7 .
fu , h. , lewis , p.r. , sendhoff , b. , tang , k. , yao , x. : what are dynamic optimization problems ? .
in : proceedings of the ieee congress on evolutionary computation , vol. 2014 , pp .
1550 - 1557 .
( 2014 ) 8 .
goldberg , d.e. , deb , k. : a comparative analysis of selection schemes used in genetic algorithms .
in : proceedings of the first workshop on foundations of genetic algorithms , foga 1991 , pp .
69 - 93 .
morgan kaufmann ( 1991 ) 9 .
jansen , t. , schellbach , u. : theoretical analysis of a mutation - based evolutionary algorithm for a tracking problem in the lattice .
in : proceedings of the 7th annual conference on genetic and evolutionary computation , gecco'05 , pp .
841 - 848 .
acm ( 2005 ) 10 .
jansen , t. , zarges , c. : evolutionary algorithms and artificial immune systems on a bi - stable dynamic optimisation problem .
in : proceedings of the 16th annual conference on genetic and evolutionary computation conference , gecco'14 , pp .
975 - 982 .
acm ( 2014 ) 11 .
kotzing , t. , lissovoi , a. , witt , c. : ( 1 + 1 ) ea on generalized dynamic onemax .
in : proceedings of the 2015 acm conference on foundations of genetic algorithms xiii , foga 2015 , pp .
40 - 51 .
acm ( 2015 ) 12 .
kotzing , t. , molter , h. : aco beats ea on a dynamic pseudo - boolean function .
in : proceedings of the 12th international conference on parallel problem solving from nature , vol. part i , ppsn'12 , pp .
113 - 122 .
springer ( 2012 ) 13 .
lehre , p.k. : fitness - levels for non - elitist populations .
in : proceedings of the 13th annual conference on genetic and evolutionary computation , gecco'11 , pp .
2075 - 2082 .
acm ( 2011 ) 14 .
lissovoi a witt c runtime analysis of ant colony optimization on dynamic shortest path problems theor. comput. sci. 2015 561 73 85 10.1016 / j.tcs.2014.06.035 15 .
lissovoi a witt c mmas vs. population - based ea on a family of dynamic fitness functions algorithmica 2016 75 3 554 576 10.1007 / s00453 - 015 - 9975 - z 16 .
mitzenmacher m upfal e probability and computing : randomized algorithms and probabilistic analysis 2005 cambridge cambridge university press 17 .
oliveto ps witt c simplified drift analysis for proving lower bounds in evolutionary computation algorithmica 2011 59 3 369 386 10.1007 / s00453 - 010 - 9387 - z 18 .
oliveto ps zarges c analysis of diversity mechanisms for optimisation in dynamic environments with low frequencies of change theor. comput. sci. 2015 561 37 67 10.1016 / j.tcs.2014.10.028 19 .
rohlfshagen , p. , lehre , p.k. , yao , x. : dynamic evolutionary optimisation : an analysis of frequency and magnitude of change .
in : proceedings of the 11th annual conference on genetic and evolutionary computation , gecco'09 , pp .
1713 - 1720 .
acm ( 2009 ) 20 .
stanhope , s.a. , daida , j. : ( 1 + 1 ) genetic algorithm fitness dynamics in a changing environment .
in : proceedings of congress in evolutionary computation , ieee cec'99 , pp .
1851 - 185 ( 1999 ) .
doi : 10.1109 / cec.1999.785499 21 .
topsoe f cho yj kim jk dragomir ss some bounds for the logarithmic function inequality theory and applications 2007 new york nova science publishers 137 151 22 .
yang , s. , yao , x .
( eds. ) : evolutionary computation for dynamic optimization problems , volume 490 of studies in computational intelligence .
springer ( 2013 )